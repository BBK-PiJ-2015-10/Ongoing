package multithreading

object Multithreading {
  
  def main(args: Array[String]): Unit = {
    
    //This is an example using atomic values
    
    var cnt = 0
    var acnt = 2
    val start = System.nanoTime()
    val threads = for (i <- 1 to 10) yield {
      new Thread(new Runnable {
        def run {
          for (j <-1 to 1000000) Multithreading.synchronized {
            cnt +=1
          }
        }
      })
    }
    
    
    //Use case illustrating the use of join and synchronization
    /*
    var cnt=0
    val start = System.nanoTime()
    val threads = for (i <-1 to 10) yield {
      new Thread(new Runnable {
        def run {
          for (j <-1 to 10000000) Multithreading.synchronized {
            cnt +=1
          }
        }
      })
    }
    threads.foreach(_.start())
    println(cnt)
    threads.foreach(_.join)
    println((System.nanoTime()-start)/1e9)
    println(cnt)
    
   
    
    //This is sequential
    
    val start2 = System.nanoTime()
    cnt = 0
    for (j <- 1 to 100000000) Multithreading.synchronized {
      cnt +=1
    }
    println((System.nanoTime()-start2)/1e9)
    println(cnt)
    
    */
    
    //Very simple use case
    /*
    new Thread(new Runnable {
      def run {
        for (i <- 1 to 15) {
          println(i)
          Thread.sleep(200)
        }
      }
    }).start
    
    for (c <- 'A' to 'Z'){
      println(c)
      Thread.sleep(100)
    }
   
  */
    
  }
  
  
  
}