package com.datax.play.spark

import org.apache.spark.SparkConf;
import org.apache.spark.SparkContext

object counter {
  
    val conf = new SparkConf().setAppName("counter").setMaster("local[*]")
    
    val sc= new SparkContext(conf)
    
    val text = sc.textFile("input/*.txt")
    
    var helper : Any = null
    
    val freqTracker: Map[String,Int] = Map()
  
  def main (args: Array[String]): Unit = {
    
      //val tester = nextWords("Munich") 
      
      testLines()
      
      //nextWords("Berlin").foreach(x=>println(x))
      
      //println("What happened")
    
  }
    
  def nextWords(first: String) : Set[String] = {
    var result : Set[String] = Set()
    val list = text.flatMap{line=>line.split(" ")}.collect().toList 
    for (i <- 0 to list.size-2){
      if (list.apply(i).equals(first)){
        result += list.apply(i+1)
      }
    }
    return result
  }
  
  def topN(set: Set[String], count: Int, first: String) : Set[String] = {
    
    var eval = 0.0
    for (second <- set){
      eval = relativeFreqTuples(first,second)
    }
 
    return null;
    
  }
  
  
  def relativeFreqTuples(first: String, second: String) : Double = {
    val array = text.flatMap{line=>line.split(" ")}
    val list = array.collect().toList
    val deno = array.filter(x=>x.equals(first)).count().toDouble
    val nume = countAdjacentTargets(first,second,list).toDouble
    println(first +" was found : " +deno +" times")
    println(second +" was found : " +nume +" times")
    return nume/deno
  }
  
  
  def countTarget(first: String) : Long = {  
    return text.flatMap{line=>line.split(" ")}.filter(x=>x.equals(first)).count()
  }
  
  def countAdjacentTargets(target1 : String, target2 : String, list :List[String]) : Long = {
    var count=0
    for ( i <- 0 to list.size-2){
      if (list.apply(i).equals(target1) && list.apply(i+1).equals(target2)){
        count +=1
      }
    }
    return count
  }
  
  /*
   * This function count words
   */
  def countWords() : Unit = {
    text.flatMap{line=>line.split(" ")}
    .map{word=>(word,1)}
    .reduceByKey(_+_).saveAsTextFile("output.txt")
  }
  
  def testLines(): Unit = {
    //text.collect()
    other("Munich",text.collect())
  }
  
  def other(target: String, lines: Array[String]): Unit = {
    for (value <- lines ) {
      if (value.contains(target)){
        println(value)
      }
    } 
  }
  
  def updateMap(first: String, line: String): Unit = {
    line.split(" ").toList
     //for (i <- 0 to temp.size-2){
      //if (temp.apply(i).equals(first)){
        //val next = temp.apply(i+1)
        
        
        //result += list.apply(i+1)
     // }
    //}
    
    
  }
  
  def aextWords(first: String) : Set[String] = {
    var result : Set[String] = Set()
    val list = text.flatMap{line=>line.split(" ")}.collect().toList 
    for (i <- 0 to list.size-2){
      if (list.apply(i).equals(first)){
        result += list.apply(i+1)
      }
    }
    return result
  }
  
  
  
}